import json
import numpy as np
import argparse
import math


def run_page(graph, damping=0.85, epsilon=5.0e-8):
  inlinks = {}
  outlink_counts = {}
  inlink_counts = {}

  for node1 in graph:
    if node1 not in outlink_counts: outlink_counts[node1] = 0
    if node1 not in inlinks: inlinks[node1] = set()
    for node2 in graph[node1]:
      if node2 not in inlinks: inlinks[node2] = set()
      if node2 not in inlink_counts: inlink_counts[node2] = 0
      if node2 not in outlink_counts: outlink_counts[node2] = 0
      if node1 not in inlinks[node1]:
        inlinks[node2].add(node1)
        inlink_counts[node2]+=1
        outlink_counts[node1]+=1
#  check for correct inlinks map
#  for node1 in graph:
#    print(node1)
#    for node2 in graph[node1]:
#      print(node2),
#    print("outcount = ", outlink_counts[node1])
#    print

  all_nodes = set(inlinks.keys())
  for node, count in outlink_counts.items():
    if count == 0:
      outlink_counts[node] = len(all_nodes)
      for l_node in all_nodes: inlinks[l_node].add(node)

  for node, count in inlink_counts.items():
    if count == 0:
      inlink_counts[node] = len(all_nodes)
      for l_node in all_nodes: 
        inlinks[node].add(l_node)
        outlink_counts[l_node]+=1

  initial_value = 1.0/len(all_nodes)
  ranks = {}
  for node in inlinks.keys(): ranks[node] = initial_value

  new_ranks = {}
  delta = 1.0
  iterations = 0
  while delta > epsilon:
    new_ranks = {}
    for node, inlink in inlinks.items():
      new_ranks[node] = ((1.0-damping)/len(all_nodes))+(damping*sum(ranks[n]/outlink_counts[n] for n in inlink))
    delta = sum(abs(new_ranks[node] - ranks[node]) for node in new_ranks.keys())
    print delta
    ranks, new_ranks = new_ranks, ranks
    iterations += 1
  return ranks, iterations



if __name__ == '__main__':
  arg_parser = argparse.ArgumentParser(description=__doc__, formatter_class=argparse.ArgumentDefaultsHelpFormatter)

  arg_parser.add_argument('--adj_list', help='path to the adjacency list life (JSON)',
                type=str, default='./adj_list.json')

  arg_parser.add_argument('--url_dict', help='path to URL to ID mapping file (JSON)',
                type=str, default='./url_dict.json')

  arg_parser.add_argument('--url_dict_reverse', help='path to ID to URL mapping file (JSON)',
                type=str, default='./url_dict_reverse.json')

  arg_parser.add_argument('--output_path', help='path to the PAGERANK output file (will be generated by this script',
                type=str, default='./pagerank_scores.json')

  arg_parser.add_argument('--query_url', help='URL for which pagerank scores need to be output',
                type=str, default='none')

  arg_parser.add_argument('--k', help='number of pagerank (top-k) for which the scores should be printed',
                type=int, default=5)
#  arg_parser.add_argument('--', help='',
#                type=, default=)

  

  args = arg_parser.parse_args();
  
  adj_list = json.load(open(args.adj_list, 'r'))
  url_dict = json.load(open(args.url_dict, 'r'))
  url_dict_reverse = json.load(open(args.url_dict_reverse, 'r'))

  pg, it = run_page(adj_list)
  print('iterations: ' + str(it))

  open(args.output_path, 'w').write(json.dumps(pg));

  if args.query_url is not 'none':
    print('Query url: '+ args.query_url)
    if args.query_url in url_dict and url_dict[args.query_url] in pg:
      print ('Page Rank = '+ str(round(pg[url_dict[args.query_url]],7)))
    else:
      print ('Page Rank = 0')

#  for node in pg:
#    print node, pg[node]
  
  pr = [(url_dict_reverse[id_], pg[id_]) for id_ in pg]
  sorted_pr = sorted(pr, key=lambda x:x[1], reverse=True)
  for tup in sorted_pr[:20]:
    print(str(tup[1])+'\t'+tup[0])

  maxVal = 0
  minVal = 1000
  stdev = np.empty()
  std = 0
  i = 0
  median = 0
  for tup in sorted_pr[:500]:
    if i == 249 or i == 250:
      median += tup[1]
    if maxVal < tup[1]:
      maxVal = tup[1]
    elif minVal > tup[1]:
      minVal = tup[1]
    np.append(tup[1])
    i+=1
  np.std(stdev)

  print("Standard Deviation = " + str(np.std(stdev)))
  print("Min = " + str(minVal))
  print("Max = " + str(maxVal))
  print("Median = " + str(median/2))

 
